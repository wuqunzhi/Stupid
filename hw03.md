
1) int8_t x = 67=(01000011)2; 

    int8_t y = -7=(11111001)2; 

    int8_t z = y - x=(10110110)2;


2) int8_t x = 0xd3;溢出

3) uint8_t = 0xd3=(11010011)2;


4) int8_t x = 127=（11111111）2; 

    int8_t y = -7=(11111001)2; 

    int8_t z = y – x溢出;


5) float x = 1.125=(1.0010000)2;

6) float x = 23.0=(10111.000)2;出现精度误差

7) float x = 0.45=(0.01110011)2;,出现精度误差




## Method of complements

mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers.

在数学和计算方面，补足法是一种仅用正数加法就能从一个数字中减去另一个数字的技术。

## byte

The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number. 

字节是数字信息的单位，通常由8位组成，代表一个二进制数。

## Integer (computer science)

In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers.

在计算机科学中，整数是整数数据类型的基准，数据类型表示一些数学整数的范围。

## Floating point


In computing, floating-point arithmetic (FP) is arithmetic using formulaic representation of real numbers as an approximation so as to support a trade-off between range and precision. 

在计算中，浮点运算(FP)是利用实数的公式化表示作为近似，以支持范围和精度之间的权衡的一种算法。





## (二)

不会


参考内容

（一. 机器数和真值

         在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.
 
1.机器数
         一个数在计算机中的二进制表示形式,  叫做这个数的机器数。
 
2.真值
         机器数的实际值称为真值。
        
3.符号数和无符号数

         符号数和无符号数是针对符号出现的两种机器数表示方法。同一个二进制数，对符号数和无符号数具有不同的含义。
         符号数如：    char, short ,int, long等类型的变量
         无符号数如：unsigned char, unsigned short , unsigned int, unsigned long, 指针等类型的变量
 

4.定点数与浮点数

         定点数和浮点数是针对小数点出现的两种机器数表示方法。
        
二. 原码, 反码, 补码的基础概念和计算方法
        
         只有符号数才有原码, 反码, 补码
         在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的一种编码方式.
 
1. 原码

 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

 [+1]原 = 0000 0001

 [-1]原 = 1000 0001

 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

 [1111 1111 , 0111 1111]
 即

 [-127 , 127]
 

2. 反码

 反码的表示方法是:正数的反码是其本身,负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

 [+1] = [00000001]原 = [00000001]反

 [-1] = [10000001]原 = [11111110]反

 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
        
3. 补码
 补码的表示方法是:正数的补码就是其本身
 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
 [+1] = [00000001]原 = [00000001]反 = [00000001]补
 [-1] = [10000001]原 = [11111110]反 = [11111111]补
 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.        
 
三. 为何要使用原码, 反码和补码
 
1.使用补码，可以将符号位和其它位统一处理；同时，减法也可按加法来处理。
2.使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].
 
         (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
 
         -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)
 
四．补码表示的溢出问题

以下是本人的补充的理解，不知道是否正确：

由于计算机中的数字用补码表示，例如8bit的byte类型的表示范围为：

[-128, 127]
0 = [0000 0000]（补）
-128 = [1000 0000]（补）
127 = [0111 1111]（补）
当byte类型的变量超上限127时，如：
+128 = -（-128）= 127 + 1 
= [1111 1111]（补）+ [0000 0001]（补） 
= [1000 0000]（补） 
= -128
+129 = 127 + 2 
= [1111 1111]（补）+ [0000 0001]（补） 
= [1000 0001]（补） 
= [1111 1111]（原） 
= -127
当byte类型的变量超过下限-128时：
-129 = -128 - 1 
= [1000 0000]（补) - [0000 0001]（补） 
= [0111 1111]（补） 
= 127
-130 = -128 - 2 
= [1000 0000]（补) - [0000 0010]（补） 
= [0111 1110]（补） 
= 126
byte a = -128, b = (byte) 128, c = (byte) 129, d = (byte) 130;
byte e = (byte) -129, f = (byte) -130;
System.out.println(a == ((byte)-a));    // true
System.out.println(b);  // -128
System.out.println(c);  // -127
System.out.println(d);  // -126
System.out.println(e);  // 127
System.out.println(f);  // 126）